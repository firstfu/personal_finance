# Sprout 2.5D SpriteKit Animation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the static SF Symbol plant visual in SproutTabView with a SpriteKit-powered 2.5D parallax scene featuring bezier-curve-drawn sprout plants, particle effects for watering, and animated stage transitions.

**Architecture:** A `SproutScene` (SKScene) manages 4 z-layers: gradient sky background, ground/pot, bezier-curve plant (stem + leaves + flower), and particle effects. The scene is embedded in SwiftUI via `SpriteView` and driven by the existing `SproutPlant` model data. Plant shapes are drawn programmatically with `SKShapeNode` + bezier curves — no external assets required.

**Tech Stack:** SpriteKit (SKScene, SKShapeNode, SKEmitterNode, SKAction), SwiftUI (SpriteView), existing SwiftData models

**Key project facts:**
- All types default to `@MainActor` (build setting `SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor`)
- Project uses `PBXFileSystemSynchronizedRootGroup` — new files in `personal_finance/` are auto-discovered by Xcode
- Brand colors: primary `#8BC34A`, primaryDark `#2E7D32`, income `#4CAF50`
- Build command: `xcodebuild -project personal_finance.xcodeproj -scheme personal_finance -destination 'platform=iOS Simulator,id=CDBF104B-5DB1-48C7-9E80-F483AC4A2C06' build`

---

### Task 1: Create ParticleEffects utility

**Files:**
- Create: `personal_finance/SpriteKit/ParticleEffects.swift`

**Step 1: Create the particle effects factory**

This file provides static factory methods that create `SKEmitterNode` instances programmatically (no .sks files needed). Three particle types: water drops, sparkles, and stage-up burst.

```swift
// personal_finance/SpriteKit/ParticleEffects.swift
import SpriteKit

enum ParticleEffects {

    /// Water drops falling from above — triggered when user records a transaction
    static func waterDrops() -> SKEmitterNode {
        let emitter = SKEmitterNode()
        emitter.particleBirthRate = 30
        emitter.numParticlesToEmit = 40
        emitter.particleLifetime = 1.2
        emitter.particleLifetimeRange = 0.3
        emitter.emissionAngle = .pi * 1.5  // downward
        emitter.emissionAngleRange = 0.3
        emitter.particleSpeed = 200
        emitter.particleSpeedRange = 50
        emitter.yAcceleration = -300  // gravity
        emitter.particleAlpha = 0.8
        emitter.particleAlphaSpeed = -0.5
        emitter.particleScale = 0.08
        emitter.particleScaleRange = 0.03
        emitter.particleColor = SKColor(red: 0.4, green: 0.7, blue: 1.0, alpha: 1.0)
        emitter.particleColorBlendFactor = 1.0
        emitter.particleBlendMode = .alpha

        // Create a small circle texture for the water drop
        let size = CGSize(width: 12, height: 16)
        let renderer = UIGraphicsImageRenderer(size: size)
        let image = renderer.image { ctx in
            let rect = CGRect(origin: .zero, size: size)
            ctx.cgContext.setFillColor(UIColor.white.cgColor)
            ctx.cgContext.fillEllipse(in: rect)
        }
        emitter.particleTexture = SKTexture(image: image)

        return emitter
    }

    /// Sparkle particles that float outward — shown after watering
    static func sparkles(color: SKColor = SKColor(red: 0.55, green: 0.76, blue: 0.29, alpha: 1.0)) -> SKEmitterNode {
        let emitter = SKEmitterNode()
        emitter.particleBirthRate = 15
        emitter.numParticlesToEmit = 25
        emitter.particleLifetime = 1.5
        emitter.particleLifetimeRange = 0.5
        emitter.emissionAngleRange = .pi * 2  // all directions
        emitter.particleSpeed = 60
        emitter.particleSpeedRange = 30
        emitter.yAcceleration = 20  // slight float upward
        emitter.particleAlpha = 0.9
        emitter.particleAlphaSpeed = -0.6
        emitter.particleScale = 0.06
        emitter.particleScaleRange = 0.03
        emitter.particleScaleSpeed = -0.02
        emitter.particleColor = color
        emitter.particleColorBlendFactor = 1.0
        emitter.particleBlendMode = .add

        // Small circle texture
        let size = CGSize(width: 10, height: 10)
        let renderer = UIGraphicsImageRenderer(size: size)
        let image = renderer.image { ctx in
            let rect = CGRect(origin: .zero, size: size)
            ctx.cgContext.setFillColor(UIColor.white.cgColor)
            ctx.cgContext.fillEllipse(in: rect)
        }
        emitter.particleTexture = SKTexture(image: image)

        return emitter
    }

    /// Big golden burst — triggered on stage up
    static func stageUpBurst() -> SKEmitterNode {
        let emitter = SKEmitterNode()
        emitter.particleBirthRate = 80
        emitter.numParticlesToEmit = 60
        emitter.particleLifetime = 1.8
        emitter.particleLifetimeRange = 0.5
        emitter.emissionAngleRange = .pi * 2
        emitter.particleSpeed = 120
        emitter.particleSpeedRange = 60
        emitter.yAcceleration = 30
        emitter.particleAlpha = 1.0
        emitter.particleAlphaSpeed = -0.5
        emitter.particleScale = 0.1
        emitter.particleScaleRange = 0.05
        emitter.particleScaleSpeed = -0.03
        emitter.particleColor = SKColor(red: 1.0, green: 0.84, blue: 0.0, alpha: 1.0) // gold
        emitter.particleColorBlendFactor = 1.0
        emitter.particleBlendMode = .add

        let size = CGSize(width: 12, height: 12)
        let renderer = UIGraphicsImageRenderer(size: size)
        let image = renderer.image { ctx in
            // Star-like shape
            let rect = CGRect(origin: .zero, size: size)
            ctx.cgContext.setFillColor(UIColor.white.cgColor)
            ctx.cgContext.fillEllipse(in: rect)
        }
        emitter.particleTexture = SKTexture(image: image)

        return emitter
    }

    /// Gentle ambient floating particles for idle state
    static func ambientGlow() -> SKEmitterNode {
        let emitter = SKEmitterNode()
        emitter.particleBirthRate = 3
        emitter.particleLifetime = 4.0
        emitter.particleLifetimeRange = 1.0
        emitter.emissionAngleRange = .pi * 2
        emitter.particleSpeed = 15
        emitter.particleSpeedRange = 10
        emitter.yAcceleration = 8
        emitter.particleAlpha = 0.3
        emitter.particleAlphaRange = 0.2
        emitter.particleAlphaSpeed = -0.08
        emitter.particleScale = 0.04
        emitter.particleScaleRange = 0.02
        emitter.particleColor = SKColor(red: 0.55, green: 0.76, blue: 0.29, alpha: 1.0)
        emitter.particleColorBlendFactor = 1.0
        emitter.particleBlendMode = .add

        let size = CGSize(width: 8, height: 8)
        let renderer = UIGraphicsImageRenderer(size: size)
        let image = renderer.image { ctx in
            let rect = CGRect(origin: .zero, size: size)
            ctx.cgContext.setFillColor(UIColor.white.cgColor)
            ctx.cgContext.fillEllipse(in: rect)
        }
        emitter.particleTexture = SKTexture(image: image)

        return emitter
    }
}
```

**Step 2: Build to verify compilation**

Run: `xcodebuild -project personal_finance.xcodeproj -scheme personal_finance -destination 'platform=iOS Simulator,id=CDBF104B-5DB1-48C7-9E80-F483AC4A2C06' build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/SpriteKit/ParticleEffects.swift
git commit -m "feat: add SpriteKit particle effects factory for sprout animations"
```

---

### Task 2: Create BackgroundNode

**Files:**
- Create: `personal_finance/SpriteKit/BackgroundNode.swift`

**Step 1: Create the gradient sky background node**

The background draws a vertical gradient that shifts color based on growth stage: warm sunrise (stage 0) through bright day (stage 2) to golden sunset (stage 4). Uses `SKShapeNode` with a texture rendered from `UIGraphicsImageRenderer`.

```swift
// personal_finance/SpriteKit/BackgroundNode.swift
import SpriteKit

final class BackgroundNode: SKNode {

    private var gradientSprite: SKSpriteNode?
    private let sceneSize: CGSize

    init(sceneSize: CGSize) {
        self.sceneSize = sceneSize
        super.init()
        self.zPosition = 0
        renderGradient(stage: 0, animated: false)
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    /// Update background color to match the current growth stage
    func updateForStage(_ stage: Int, animated: Bool) {
        renderGradient(stage: stage, animated: animated)
    }

    private func renderGradient(stage: Int, animated: Bool) {
        let colors = gradientColors(for: stage)
        let texture = createGradientTexture(
            size: sceneSize,
            topColor: colors.top,
            bottomColor: colors.bottom
        )

        if let existing = gradientSprite {
            if animated {
                let newSprite = SKSpriteNode(texture: texture, size: sceneSize)
                newSprite.position = CGPoint(x: sceneSize.width / 2, y: sceneSize.height / 2)
                newSprite.alpha = 0
                newSprite.zPosition = 0
                addChild(newSprite)

                newSprite.run(.fadeIn(withDuration: 1.0))
                existing.run(.sequence([
                    .fadeOut(withDuration: 1.0),
                    .removeFromParent()
                ]))
                gradientSprite = newSprite
            } else {
                existing.texture = texture
            }
        } else {
            let sprite = SKSpriteNode(texture: texture, size: sceneSize)
            sprite.position = CGPoint(x: sceneSize.width / 2, y: sceneSize.height / 2)
            sprite.zPosition = 0
            addChild(sprite)
            gradientSprite = sprite
        }
    }

    private func gradientColors(for stage: Int) -> (top: UIColor, bottom: UIColor) {
        switch stage {
        case 0: // Warm sunrise — seed waiting
            return (
                top: UIColor(red: 0.98, green: 0.85, blue: 0.65, alpha: 1.0),
                bottom: UIColor(red: 0.95, green: 0.92, blue: 0.82, alpha: 1.0)
            )
        case 1: // Early morning — sprouting
            return (
                top: UIColor(red: 0.75, green: 0.90, blue: 0.95, alpha: 1.0),
                bottom: UIColor(red: 0.90, green: 0.95, blue: 0.88, alpha: 1.0)
            )
        case 2: // Bright day — growing
            return (
                top: UIColor(red: 0.55, green: 0.82, blue: 0.95, alpha: 1.0),
                bottom: UIColor(red: 0.85, green: 0.95, blue: 0.85, alpha: 1.0)
            )
        case 3: // Lush afternoon
            return (
                top: UIColor(red: 0.45, green: 0.75, blue: 0.92, alpha: 1.0),
                bottom: UIColor(red: 0.78, green: 0.93, blue: 0.78, alpha: 1.0)
            )
        default: // Golden hour — blooming (stage 4)
            return (
                top: UIColor(red: 1.0, green: 0.85, blue: 0.55, alpha: 1.0),
                bottom: UIColor(red: 0.95, green: 0.95, blue: 0.80, alpha: 1.0)
            )
        }
    }

    private func createGradientTexture(size: CGSize, topColor: UIColor, bottomColor: UIColor) -> SKTexture {
        let renderer = UIGraphicsImageRenderer(size: size)
        let image = renderer.image { ctx in
            let colorSpace = CGColorSpaceCreateDeviceRGB()
            let colors = [topColor.cgColor, bottomColor.cgColor] as CFArray
            let locations: [CGFloat] = [0.0, 1.0]
            if let gradient = CGGradient(colorsSpace: colorSpace, colors: colors, locations: locations) {
                ctx.cgContext.drawLinearGradient(
                    gradient,
                    start: CGPoint(x: 0, y: 0),
                    end: CGPoint(x: 0, y: size.height),
                    options: []
                )
            }
        }
        return SKTexture(image: image)
    }
}
```

**Step 2: Build to verify**

Run: `xcodebuild ... build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/SpriteKit/BackgroundNode.swift
git commit -m "feat: add gradient sky background node for sprout scene"
```

---

### Task 3: Create GroundNode

**Files:**
- Create: `personal_finance/SpriteKit/GroundNode.swift`

**Step 1: Create the ground and pot node**

Draws a curved earth mound with a simple pot shape using bezier paths. The pot sits at the bottom-center of the scene. The earth has a subtle arc to give depth.

```swift
// personal_finance/SpriteKit/GroundNode.swift
import SpriteKit

final class GroundNode: SKNode {

    private let sceneSize: CGSize

    init(sceneSize: CGSize) {
        self.sceneSize = sceneSize
        super.init()
        self.zPosition = 1
        setupGround()
        setupPot()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private func setupGround() {
        let path = CGMutablePath()
        let w = sceneSize.width
        let groundY = sceneSize.height * 0.22

        // Curved earth mound
        path.move(to: CGPoint(x: 0, y: 0))
        path.addLine(to: CGPoint(x: 0, y: groundY * 0.6))
        path.addQuadCurve(
            to: CGPoint(x: w, y: groundY * 0.6),
            control: CGPoint(x: w / 2, y: groundY * 1.1)
        )
        path.addLine(to: CGPoint(x: w, y: 0))
        path.closeSubpath()

        let ground = SKShapeNode(path: path)
        ground.fillColor = SKColor(red: 0.55, green: 0.38, blue: 0.22, alpha: 1.0) // brown earth
        ground.strokeColor = SKColor(red: 0.45, green: 0.30, blue: 0.18, alpha: 1.0)
        ground.lineWidth = 1.5
        addChild(ground)

        // Grass line on top
        let grassPath = CGMutablePath()
        grassPath.move(to: CGPoint(x: 0, y: groundY * 0.6))
        grassPath.addQuadCurve(
            to: CGPoint(x: w, y: groundY * 0.6),
            control: CGPoint(x: w / 2, y: groundY * 1.1)
        )

        let grass = SKShapeNode(path: grassPath)
        grass.strokeColor = SKColor(red: 0.4, green: 0.65, blue: 0.2, alpha: 1.0) // green grass
        grass.lineWidth = 4
        grass.lineCap = .round
        addChild(grass)
    }

    private func setupPot() {
        let potWidth: CGFloat = 80
        let potHeight: CGFloat = 55
        let potX = sceneSize.width / 2
        let potBaseY = sceneSize.height * 0.22

        let path = CGMutablePath()
        // Pot is a trapezoid: wider at top, narrower at bottom
        let topHalf = potWidth / 2
        let bottomHalf = potWidth * 0.35
        let rimHeight: CGFloat = 8

        // Main pot body
        path.move(to: CGPoint(x: potX - topHalf, y: potBaseY + potHeight))
        path.addLine(to: CGPoint(x: potX - bottomHalf, y: potBaseY))
        path.addLine(to: CGPoint(x: potX + bottomHalf, y: potBaseY))
        path.addLine(to: CGPoint(x: potX + topHalf, y: potBaseY + potHeight))
        path.closeSubpath()

        let pot = SKShapeNode(path: path)
        pot.fillColor = SKColor(red: 0.76, green: 0.50, blue: 0.32, alpha: 1.0) // terracotta
        pot.strokeColor = SKColor(red: 0.60, green: 0.38, blue: 0.22, alpha: 1.0)
        pot.lineWidth = 1.5
        addChild(pot)

        // Pot rim (slightly wider rectangle at the top)
        let rimPath = CGMutablePath()
        let rimHalf = topHalf + 5
        rimPath.move(to: CGPoint(x: potX - rimHalf, y: potBaseY + potHeight))
        rimPath.addLine(to: CGPoint(x: potX - rimHalf, y: potBaseY + potHeight + rimHeight))
        rimPath.addLine(to: CGPoint(x: potX + rimHalf, y: potBaseY + potHeight + rimHeight))
        rimPath.addLine(to: CGPoint(x: potX + rimHalf, y: potBaseY + potHeight))
        rimPath.closeSubpath()

        let rim = SKShapeNode(path: rimPath)
        rim.fillColor = SKColor(red: 0.70, green: 0.45, blue: 0.28, alpha: 1.0)
        rim.strokeColor = SKColor(red: 0.55, green: 0.35, blue: 0.20, alpha: 1.0)
        rim.lineWidth = 1.5
        addChild(rim)

        // Soil inside pot (dark brown ellipse at the top of pot)
        let soilPath = CGMutablePath()
        soilPath.addEllipse(in: CGRect(
            x: potX - topHalf + 5,
            y: potBaseY + potHeight - 4,
            width: (topHalf - 5) * 2,
            height: rimHeight + 6
        ))
        let soil = SKShapeNode(path: soilPath)
        soil.fillColor = SKColor(red: 0.35, green: 0.25, blue: 0.15, alpha: 1.0)
        soil.strokeColor = .clear
        soil.zPosition = 0.1
        addChild(soil)
    }
}
```

**Step 2: Build to verify**

Run: `xcodebuild ... build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/SpriteKit/GroundNode.swift
git commit -m "feat: add ground and pot node for sprout scene"
```

---

### Task 4: Create PlantNode — the core bezier-curve plant

**Files:**
- Create: `personal_finance/SpriteKit/PlantNode.swift`

**Step 1: Create the plant node with all 5 stages**

This is the most complex file. It draws the sprout using bezier curves and supports morphing between stages. Each stage adds more elements: seed → stem+cotyledon → stem+leaves → bushy → flower.

```swift
// personal_finance/SpriteKit/PlantNode.swift
import SpriteKit

final class PlantNode: SKNode {

    /// The pot-top Y position — plant grows upward from here
    private let baseY: CGFloat
    private let centerX: CGFloat
    private var currentStage: Int = -1

    // Child nodes
    private var seedNode: SKShapeNode?
    private var stemNode: SKShapeNode?
    private var leaves: [SKShapeNode] = []
    private var flowerNode: SKNode?

    init(sceneSize: CGSize) {
        self.centerX = sceneSize.width / 2
        self.baseY = sceneSize.height * 0.22 + 55 + 4 // ground + pot height + soil offset
        super.init()
        self.zPosition = 2
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    // MARK: - Public API

    /// Set the plant to a specific stage (0-4). If animated, morphs over 0.8s.
    func morphTo(stage: Int, animated: Bool) {
        guard stage != currentStage else { return }
        let oldStage = currentStage
        currentStage = stage

        if animated && oldStage >= 0 {
            // Fade out old, build new, fade in
            let snapshot = self.children.map { $0 }
            buildStage(stage)
            let newChildren = self.children.filter { !snapshot.contains($0) }
            newChildren.forEach { $0.alpha = 0 }

            let fadeOut = SKAction.fadeOut(withDuration: 0.4)
            let fadeIn = SKAction.fadeIn(withDuration: 0.4)

            for old in snapshot {
                old.run(.sequence([fadeOut, .removeFromParent()]))
            }
            for new in newChildren {
                new.run(.sequence([.wait(forDuration: 0.3), fadeIn]))
            }

            // Restart idle after morph
            run(.sequence([.wait(forDuration: 0.8), .run { [weak self] in
                self?.startIdleAnimation()
            }]))
        } else {
            removeAllChildren()
            buildStage(stage)
            startIdleAnimation()
        }
    }

    /// Animate a small growth spurt (stem grows taller by a few points)
    func playGrowthSpurt() {
        guard let stem = stemNode else { return }
        let grow = SKAction.moveBy(x: 0, y: 3, duration: 0.6)
        grow.timingMode = .easeOut
        let shrink = SKAction.moveBy(x: 0, y: -1.5, duration: 0.3)
        shrink.timingMode = .easeIn
        stem.run(.sequence([grow, shrink]))

        // Leaves also bounce
        for leaf in leaves {
            let scale = SKAction.sequence([
                .scale(to: 1.1, duration: 0.4),
                .scale(to: 1.0, duration: 0.3)
            ])
            leaf.run(scale)
        }
    }

    /// Start the idle swaying animation
    func startIdleAnimation() {
        removeAction(forKey: "idle")

        for (i, leaf) in leaves.enumerated() {
            leaf.removeAction(forKey: "sway")
            let delay = Double(i) * 0.3
            let duration = 2.5 + Double(i) * 0.2
            let angle: CGFloat = .pi / 36 // ±5 degrees
            let sway = SKAction.sequence([
                .wait(forDuration: delay),
                .repeatForever(.sequence([
                    .rotate(byAngle: angle, duration: duration / 2),
                    .rotate(byAngle: -angle * 2, duration: duration),
                    .rotate(byAngle: angle, duration: duration / 2)
                ]))
            ])
            leaf.run(sway, withKey: "sway")
        }

        // Seed breathing
        if let seed = seedNode, currentStage == 0 {
            let breathe = SKAction.repeatForever(.sequence([
                .scale(to: 1.03, duration: 1.5),
                .scale(to: 0.97, duration: 1.5)
            ]))
            seed.run(breathe, withKey: "idle")
        }

        // Flower gentle rotation
        if let flower = flowerNode {
            let rotate = SKAction.repeatForever(.sequence([
                .rotate(byAngle: .pi / 60, duration: 2.0),
                .rotate(byAngle: -.pi / 30, duration: 4.0),
                .rotate(byAngle: .pi / 60, duration: 2.0)
            ]))
            flower.run(rotate, withKey: "idle")
        }
    }

    // MARK: - Stage Building

    private func buildStage(_ stage: Int) {
        seedNode = nil
        stemNode = nil
        leaves = []
        flowerNode = nil

        switch stage {
        case 0: buildSeed()
        case 1: buildSprout()
        case 2: buildSeedling()
        case 3: buildBushy()
        default: buildFlowering()
        }
    }

    // Stage 0: Seed
    private func buildSeed() {
        let seed = SKShapeNode(ellipseOf: CGSize(width: 24, height: 18))
        seed.position = CGPoint(x: centerX, y: baseY + 8)
        seed.fillColor = SKColor(red: 0.55, green: 0.38, blue: 0.18, alpha: 1.0)
        seed.strokeColor = SKColor(red: 0.45, green: 0.30, blue: 0.15, alpha: 1.0)
        seed.lineWidth = 1.5
        addChild(seed)
        seedNode = seed

        // Small crack line on seed
        let crackPath = CGMutablePath()
        crackPath.move(to: CGPoint(x: centerX - 2, y: baseY + 12))
        crackPath.addLine(to: CGPoint(x: centerX + 1, y: baseY + 8))
        crackPath.addLine(to: CGPoint(x: centerX - 1, y: baseY + 4))
        let crack = SKShapeNode(path: crackPath)
        crack.strokeColor = SKColor(red: 0.40, green: 0.28, blue: 0.12, alpha: 0.6)
        crack.lineWidth = 1
        addChild(crack)
    }

    // Stage 1: Sprout — short stem + two cotyledons
    private func buildSprout() {
        let stemHeight: CGFloat = 50
        let stemPath = createStemPath(height: stemHeight, curve: 8, width: 3)
        let stem = SKShapeNode(path: stemPath)
        stem.strokeColor = SKColor(red: 0.45, green: 0.72, blue: 0.22, alpha: 1.0)
        stem.lineWidth = 3
        stem.lineCap = .round
        stem.fillColor = .clear
        addChild(stem)
        stemNode = stem

        // Two cotyledons (small oval leaves)
        let leftLeaf = createLeaf(
            at: CGPoint(x: centerX - 5, y: baseY + stemHeight - 5),
            size: CGSize(width: 18, height: 10),
            angle: -.pi / 5,
            color: SKColor(red: 0.55, green: 0.78, blue: 0.25, alpha: 1.0)
        )
        addChild(leftLeaf)
        leaves.append(leftLeaf)

        let rightLeaf = createLeaf(
            at: CGPoint(x: centerX + 5, y: baseY + stemHeight - 5),
            size: CGSize(width: 18, height: 10),
            angle: .pi / 5,
            color: SKColor(red: 0.55, green: 0.78, blue: 0.25, alpha: 1.0)
        )
        addChild(rightLeaf)
        leaves.append(rightLeaf)
    }

    // Stage 2: Seedling — taller stem + 2-3 real leaves
    private func buildSeedling() {
        let stemHeight: CGFloat = 90
        let stemPath = createStemPath(height: stemHeight, curve: 12, width: 4)
        let stem = SKShapeNode(path: stemPath)
        stem.strokeColor = SKColor(red: 0.40, green: 0.68, blue: 0.20, alpha: 1.0)
        stem.lineWidth = 4
        stem.lineCap = .round
        stem.fillColor = .clear
        addChild(stem)
        stemNode = stem

        let leafPositions: [(CGPoint, CGSize, CGFloat)] = [
            (CGPoint(x: centerX - 8, y: baseY + stemHeight * 0.5), CGSize(width: 28, height: 14), -.pi / 4),
            (CGPoint(x: centerX + 8, y: baseY + stemHeight * 0.7), CGSize(width: 32, height: 16), .pi / 4.5),
            (CGPoint(x: centerX - 5, y: baseY + stemHeight - 8), CGSize(width: 24, height: 12), -.pi / 6),
        ]

        for (pos, size, angle) in leafPositions {
            let leaf = createLeaf(
                at: pos, size: size, angle: angle,
                color: SKColor(red: 0.50, green: 0.76, blue: 0.22, alpha: 1.0)
            )
            addChild(leaf)
            leaves.append(leaf)
        }
    }

    // Stage 3: Bushy — thick stem + many leaves + branches
    private func buildBushy() {
        let stemHeight: CGFloat = 130
        let stemPath = createStemPath(height: stemHeight, curve: 15, width: 5)
        let stem = SKShapeNode(path: stemPath)
        stem.strokeColor = SKColor(red: 0.30, green: 0.55, blue: 0.15, alpha: 1.0)
        stem.lineWidth = 5.5
        stem.lineCap = .round
        stem.fillColor = .clear
        addChild(stem)
        stemNode = stem

        // Small branches
        let branch1 = createBranch(
            from: CGPoint(x: centerX - 3, y: baseY + stemHeight * 0.55),
            length: 25, angle: -.pi / 3
        )
        addChild(branch1)

        let branch2 = createBranch(
            from: CGPoint(x: centerX + 3, y: baseY + stemHeight * 0.75),
            length: 20, angle: .pi / 3.5
        )
        addChild(branch2)

        let leafPositions: [(CGPoint, CGSize, CGFloat)] = [
            (CGPoint(x: centerX - 25, y: baseY + stemHeight * 0.55), CGSize(width: 30, height: 16), -.pi / 3.5),
            (CGPoint(x: centerX + 10, y: baseY + stemHeight * 0.4), CGSize(width: 34, height: 17), .pi / 5),
            (CGPoint(x: centerX + 22, y: baseY + stemHeight * 0.75), CGSize(width: 32, height: 15), .pi / 3.5),
            (CGPoint(x: centerX - 12, y: baseY + stemHeight * 0.8), CGSize(width: 28, height: 14), -.pi / 5),
            (CGPoint(x: centerX + 5, y: baseY + stemHeight - 10), CGSize(width: 26, height: 13), .pi / 7),
            (CGPoint(x: centerX - 8, y: baseY + stemHeight - 5), CGSize(width: 24, height: 12), -.pi / 8),
        ]

        for (pos, size, angle) in leafPositions {
            let leaf = createLeaf(
                at: pos, size: size, angle: angle,
                color: SKColor(red: 0.35, green: 0.65, blue: 0.18, alpha: 1.0)
            )
            addChild(leaf)
            leaves.append(leaf)
        }
    }

    // Stage 4: Flowering — bushy + flower on top
    private func buildFlowering() {
        // Build the bushy base first
        buildBushy()

        // Add flower on top
        let flower = SKNode()
        let flowerY = baseY + 135
        flower.position = CGPoint(x: centerX, y: flowerY)

        // Petals (5 oval petals arranged in a circle)
        let petalCount = 5
        let petalColor = SKColor(red: 1.0, green: 0.75, blue: 0.85, alpha: 1.0)
        for i in 0..<petalCount {
            let angle = CGFloat(i) * (.pi * 2 / CGFloat(petalCount)) - .pi / 2
            let petalPath = CGMutablePath()
            petalPath.addEllipse(in: CGRect(x: -6, y: 0, width: 12, height: 20))
            let petal = SKShapeNode(path: petalPath)
            petal.fillColor = petalColor
            petal.strokeColor = SKColor(red: 0.95, green: 0.60, blue: 0.70, alpha: 0.8)
            petal.lineWidth = 1
            petal.zRotation = angle
            petal.position = CGPoint(
                x: cos(angle) * 8,
                y: sin(angle) * 8
            )
            flower.addChild(petal)
        }

        // Center of flower
        let center = SKShapeNode(circleOfRadius: 7)
        center.fillColor = SKColor(red: 1.0, green: 0.85, blue: 0.30, alpha: 1.0) // yellow
        center.strokeColor = SKColor(red: 0.9, green: 0.75, blue: 0.20, alpha: 1.0)
        center.lineWidth = 1
        center.zPosition = 0.1
        flower.addChild(center)

        // Glow behind flower
        let glow = SKShapeNode(circleOfRadius: 25)
        glow.fillColor = SKColor(red: 1.0, green: 0.95, blue: 0.60, alpha: 0.25)
        glow.strokeColor = .clear
        glow.zPosition = -0.1
        flower.addChild(glow)

        addChild(flower)
        flowerNode = flower
    }

    // MARK: - Drawing Helpers

    private func createStemPath(height: CGFloat, curve: CGFloat, width: CGFloat) -> CGPath {
        let path = CGMutablePath()
        path.move(to: CGPoint(x: centerX, y: baseY))
        path.addQuadCurve(
            to: CGPoint(x: centerX + curve * 0.3, y: baseY + height),
            control: CGPoint(x: centerX - curve, y: baseY + height * 0.5)
        )
        return path
    }

    private func createLeaf(at position: CGPoint, size: CGSize, angle: CGFloat, color: SKColor) -> SKShapeNode {
        let path = CGMutablePath()
        // Leaf shape: pointed ellipse using bezier curves
        path.move(to: CGPoint(x: 0, y: 0))
        path.addQuadCurve(
            to: CGPoint(x: size.width, y: 0),
            control: CGPoint(x: size.width * 0.5, y: size.height)
        )
        path.addQuadCurve(
            to: CGPoint(x: 0, y: 0),
            control: CGPoint(x: size.width * 0.5, y: -size.height * 0.3)
        )

        let leaf = SKShapeNode(path: path)
        leaf.fillColor = color
        leaf.strokeColor = SKColor(
            red: color.redComponent * 0.8,
            green: color.greenComponent * 0.8,
            blue: color.blueComponent * 0.8,
            alpha: 0.8
        )
        leaf.lineWidth = 1
        leaf.position = position
        leaf.zRotation = angle
        return leaf
    }

    private func createBranch(from start: CGPoint, length: CGFloat, angle: CGFloat) -> SKShapeNode {
        let endX = start.x + cos(angle) * length
        let endY = start.y + sin(angle) * length
        let path = CGMutablePath()
        path.move(to: start)
        path.addLine(to: CGPoint(x: endX, y: endY))
        let branch = SKShapeNode(path: path)
        branch.strokeColor = SKColor(red: 0.35, green: 0.58, blue: 0.18, alpha: 1.0)
        branch.lineWidth = 2.5
        branch.lineCap = .round
        return branch
    }
}

// MARK: - SKColor helpers

private extension SKColor {
    var redComponent: CGFloat {
        var r: CGFloat = 0; getRed(&r, green: nil, blue: nil, alpha: nil); return r
    }
    var greenComponent: CGFloat {
        var g: CGFloat = 0; getRed(nil, green: &g, blue: nil, alpha: nil); return g
    }
    var blueComponent: CGFloat {
        var b: CGFloat = 0; getRed(nil, green: nil, blue: &b, alpha: nil); return b
    }
}
```

**Step 2: Build to verify**

Run: `xcodebuild ... build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/SpriteKit/PlantNode.swift
git commit -m "feat: add bezier-curve plant node with 5 growth stages"
```

---

### Task 5: Create SproutScene — the main orchestrator

**Files:**
- Create: `personal_finance/SpriteKit/SproutScene.swift`

**Step 1: Create the main SpriteKit scene**

This scene ties all the layers together and exposes the public API that SwiftUI will call.

```swift
// personal_finance/SpriteKit/SproutScene.swift
import SpriteKit

final class SproutScene: SKScene {

    private var backgroundNode: BackgroundNode?
    private var groundNode: GroundNode?
    private var plantNode: PlantNode?
    private var ambientEmitter: SKEmitterNode?

    private var currentStage: Int = -1

    override func didMove(to view: SKView) {
        backgroundColor = .clear
        scaleMode = .aspectFit

        let bg = BackgroundNode(sceneSize: size)
        addChild(bg)
        backgroundNode = bg

        let ground = GroundNode(sceneSize: size)
        addChild(ground)
        groundNode = ground

        let plant = PlantNode(sceneSize: size)
        addChild(plant)
        plantNode = plant

        // Ambient glow particles
        let ambient = ParticleEffects.ambientGlow()
        ambient.position = CGPoint(x: size.width / 2, y: size.height * 0.5)
        ambient.zPosition = 3
        ambient.particlePositionRange = CGVector(dx: size.width * 0.6, dy: size.height * 0.4)
        addChild(ambient)
        ambientEmitter = ambient
    }

    // MARK: - Public API

    /// Configure scene to display a specific stage. Call on initial load.
    func configure(stage: Int, growthPoints: Int) {
        guard currentStage != stage else { return }
        let animated = currentStage >= 0
        currentStage = stage
        plantNode?.morphTo(stage: stage, animated: animated)
        backgroundNode?.updateForStage(stage, animated: animated)
    }

    /// Play the watering animation sequence (~2.5s)
    func playWaterAnimation(pointsEarned: Int, completion: (() -> Void)? = nil) {
        // 1. Water drops from top
        let waterDrops = ParticleEffects.waterDrops()
        waterDrops.position = CGPoint(x: size.width / 2, y: size.height * 0.85)
        waterDrops.zPosition = 3
        waterDrops.particlePositionRange = CGVector(dx: 80, dy: 0)
        addChild(waterDrops)

        // Remove water drops after they finish
        waterDrops.run(.sequence([
            .wait(forDuration: 1.5),
            .run { waterDrops.particleBirthRate = 0 },
            .wait(forDuration: 1.5),
            .removeFromParent()
        ]))

        // 2. Plant growth spurt (after 0.5s delay)
        run(.sequence([
            .wait(forDuration: 0.5),
            .run { [weak self] in
                self?.plantNode?.playGrowthSpurt()
            }
        ]))

        // 3. Sparkles from plant center (after 1.5s)
        run(.sequence([
            .wait(forDuration: 1.5),
            .run { [weak self] in
                guard let self else { return }
                let sparkles = ParticleEffects.sparkles()
                sparkles.position = CGPoint(x: self.size.width / 2, y: self.size.height * 0.55)
                sparkles.zPosition = 3
                self.addChild(sparkles)

                sparkles.run(.sequence([
                    .wait(forDuration: 1.5),
                    .run { sparkles.particleBirthRate = 0 },
                    .wait(forDuration: 2.0),
                    .removeFromParent()
                ]))
            }
        ]))

        // Completion callback
        run(.sequence([
            .wait(forDuration: 2.5),
            .run { completion?() }
        ]))
    }

    /// Play the stage-up celebration animation (~3s)
    func playStageUpAnimation(newStage: Int, completion: (() -> Void)? = nil) {
        // 1. Flash white
        let flash = SKShapeNode(rectOf: size)
        flash.position = CGPoint(x: size.width / 2, y: size.height / 2)
        flash.fillColor = .white
        flash.strokeColor = .clear
        flash.alpha = 0
        flash.zPosition = 10
        addChild(flash)

        flash.run(.sequence([
            .fadeAlpha(to: 0.6, duration: 0.1),
            .fadeOut(withDuration: 0.3),
            .removeFromParent()
        ]))

        // 2. Morph plant to new stage
        run(.sequence([
            .wait(forDuration: 0.2),
            .run { [weak self] in
                self?.currentStage = newStage
                self?.plantNode?.morphTo(stage: newStage, animated: true)
                self?.backgroundNode?.updateForStage(newStage, animated: true)
            }
        ]))

        // 3. Golden burst
        run(.sequence([
            .wait(forDuration: 0.5),
            .run { [weak self] in
                guard let self else { return }
                let burst = ParticleEffects.stageUpBurst()
                burst.position = CGPoint(x: self.size.width / 2, y: self.size.height * 0.55)
                burst.zPosition = 3
                self.addChild(burst)

                burst.run(.sequence([
                    .wait(forDuration: 0.8),
                    .run { burst.particleBirthRate = 0 },
                    .wait(forDuration: 2.0),
                    .removeFromParent()
                ]))
            }
        ]))

        // Completion
        run(.sequence([
            .wait(forDuration: 3.0),
            .run { completion?() }
        ]))
    }
}
```

**Step 2: Build to verify**

Run: `xcodebuild ... build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/SpriteKit/SproutScene.swift
git commit -m "feat: add SproutScene orchestrating all spritekit layers"
```

---

### Task 6: Update SproutTabView to use SpriteView

**Files:**
- Modify: `personal_finance/Views/SproutTabView.swift`

**Step 1: Replace the plantVisual with SpriteView**

Key changes:
1. Add `import SpriteKit`
2. Replace `@State private var animatePlant` with `@State private var sproutScene: SproutScene?`
3. Replace the `plantVisual` computed property to use `SpriteView`
4. In `onAppear`, create the scene and configure it
5. Add an `.onChange(of:)` modifier to update scene when plant data changes
6. Update `performHarvest()` to trigger scene celebration

Replace the entire `SproutTabView.swift` with:

```swift
// personal_finance/Views/SproutTabView.swift
import SwiftUI
import SwiftData
import SpriteKit

struct SproutTabView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(filter: #Predicate<SproutPlant> { $0.isActive == true })
    private var activePlants: [SproutPlant]

    @State private var showHarvestGallery = false
    @State private var showHarvestCelebration = false
    @State private var sproutScene: SproutScene?

    private var plant: SproutPlant? {
        activePlants.first
    }

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 24) {
                    plantVisual
                        .padding(.top, 20)

                    progressSection

                    statsCard

                    todayStatusCard

                    if plant?.isReadyToHarvest == true {
                        harvestButton
                    }
                }
                .padding(.horizontal, AppTheme.horizontalPadding)
                .padding(.bottom, 32)
            }
            .background(Color(.systemGroupedBackground))
            .navigationTitle("我的豆芽")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        showHarvestGallery = true
                    } label: {
                        Image(systemName: "trophy.fill")
                            .foregroundStyle(AppTheme.primary)
                    }
                }
            }
            .sheet(isPresented: $showHarvestGallery) {
                HarvestGalleryView()
            }
            .onAppear {
                ensurePlantExists()
                setupScene()
            }
            .onChange(of: plant?.currentStage) { _, newStage in
                if let stage = newStage {
                    sproutScene?.configure(stage: stage, growthPoints: plant?.growthPoints ?? 0)
                }
            }
            .overlay {
                if showHarvestCelebration {
                    harvestCelebrationOverlay
                }
            }
        }
    }

    // MARK: - SpriteKit Plant Visual

    private var plantVisual: some View {
        VStack(spacing: 16) {
            if let scene = sproutScene {
                SpriteView(scene: scene, options: [.allowsTransparency])
                    .frame(width: 350, height: 350)
                    .clipShape(RoundedRectangle(cornerRadius: 24))
            } else {
                // Fallback while scene loads
                ProgressView()
                    .frame(width: 350, height: 350)
            }

            Text(plant?.stageName ?? "種子")
                .font(.title2.bold())
                .foregroundStyle(AppTheme.onBackground)
        }
    }

    // ... rest of the view (progressSection, statsCard, todayStatusCard,
    //     harvestButton, harvestCelebrationOverlay, helpers) stays EXACTLY the same
    //     as the current implementation — no changes needed.

    // MARK: - Scene Setup

    private func setupScene() {
        if sproutScene == nil {
            let scene = SproutScene(size: CGSize(width: 400, height: 400))
            scene.scaleMode = .aspectFit
            scene.backgroundColor = .clear
            sproutScene = scene
        }
        let stage = plant?.currentStage ?? 0
        sproutScene?.configure(stage: stage, growthPoints: plant?.growthPoints ?? 0)
    }

    // Keep ALL existing sections unchanged:
    // progressSection, statsCard, statsRow, todayStatusCard,
    // harvestButton, harvestCelebrationOverlay, hasWateredToday,
    // stageColor, stageGradient (stageGradient still used by progressSection tint)

    // ONLY change performHarvest to add scene animation:
    private func performHarvest() {
        let service = SproutGrowthService(modelContext: modelContext)
        if service.harvestPlant() != nil {
            UINotificationFeedbackGenerator().notificationOccurred(.success)

            // Play scene celebration before showing overlay
            sproutScene?.playStageUpAnimation(newStage: 0) { [self] in
                setupScene() // refresh scene for new plant
            }

            withAnimation {
                showHarvestCelebration = true
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                withAnimation {
                    showHarvestCelebration = false
                }
            }
        }
    }
}
```

**Important:** Keep every section that isn't explicitly listed for change (progressSection, statsCard, etc.) exactly as-is. Only replace: imports, state vars, `plantVisual`, add `setupScene()`, add `.onChange`, and update `performHarvest()`.

**Step 2: Build to verify**

Run: `xcodebuild ... build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/Views/SproutTabView.swift
git commit -m "feat: replace SF Symbol plant with SpriteKit 2.5D scene"
```

---

### Task 7: Update AddTransactionView growth overlay with SpriteKit

**Files:**
- Modify: `personal_finance/Views/AddTransactionView.swift`

**Step 1: Add a mini SpriteKit scene to the growth overlay**

Replace the `growthOverlay` computed property (lines 554-581) to include a small inline SpriteKit scene that plays the water animation. Also add a `@State` for the mini scene.

Add to the state variables section (after line 23):
```swift
@State private var miniSproutScene: SproutScene?
```

Replace the `growthOverlay` property:
```swift
private var growthOverlay: some View {
    VStack(spacing: 12) {
        // Mini SpriteKit scene showing watering animation
        if let scene = miniSproutScene {
            SpriteView(scene: scene, options: [.allowsTransparency])
                .frame(width: 150, height: 150)
                .clipShape(Circle())
        } else {
            Image(systemName: "sparkles")
                .font(.system(size: 48))
                .foregroundStyle(AppTheme.primary)
                .symbolEffect(.bounce, value: showGrowthPopup)
        }

        Text("豆芽獲得成長！")
            .font(.headline)
            .foregroundStyle(AppTheme.onBackground)

        Text("+\(growthPointsEarned) 點")
            .font(.title2.bold())
            .foregroundStyle(AppTheme.primaryDark)

        if didStageUp {
            Text("豆芽成長為：\(newStageName)！")
                .font(.subheadline.bold())
                .foregroundStyle(AppTheme.income)
                .padding(.top, 4)
        }
    }
    .padding(36)
    .background(.ultraThinMaterial)
    .clipShape(RoundedRectangle(cornerRadius: 20))
    .shadow(color: .black.opacity(0.1), radius: 20, y: 10)
    .transition(.scale.combined(with: .opacity))
}
```

In `saveTransaction`, where the growth popup is shown (around line 515-528), add the mini scene setup:
```swift
// Inside the `if growthResult.didGrow` block, before showing popup:
let stage = SproutGrowthService.stageForPoints(
    sproutService.getActivePlant().growthPoints
)
let mini = SproutScene(size: CGSize(width: 200, height: 200))
mini.scaleMode = .aspectFit
mini.backgroundColor = .clear
miniSproutScene = mini

// After setting showGrowthPopup = true, trigger animation:
DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
    mini.configure(stage: stage, growthPoints: 0)
    mini.playWaterAnimation(pointsEarned: growthResult.pointsEarned)
}
```

Also add `import SpriteKit` at the top of the file.

When `showGrowthPopup` is set to false, clean up:
```swift
miniSproutScene = nil
```

**Step 2: Build to verify**

Run: `xcodebuild ... build 2>&1 | tail -5`
Expected: `** BUILD SUCCEEDED **`

**Step 3: Commit**

```bash
git add personal_finance/Views/AddTransactionView.swift
git commit -m "feat: add mini SpriteKit scene to growth overlay in AddTransactionView"
```

---

### Task 8: Final build verification and CLAUDE.md update

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Run full build**

Run: `xcodebuild -project personal_finance.xcodeproj -scheme personal_finance -destination 'platform=iOS Simulator,id=CDBF104B-5DB1-48C7-9E80-F483AC4A2C06' build 2>&1 | tail -10`
Expected: `** BUILD SUCCEEDED **`

**Step 2: Update CLAUDE.md**

In the "豆芽養成功能" section, update the animation line from:
```
- 使用 SF Symbols + SwiftUI 原生動畫（未來可升級為 Lottie）
```
to:
```
- 使用 SpriteKit 2.5D Parallax 動畫（SKShapeNode 貝茲曲線繪製、SKEmitterNode 粒子效果）
- SpriteKit 檔案位於 `SpriteKit/` 目錄：SproutScene、PlantNode、GroundNode、BackgroundNode、ParticleEffects
```

**Step 3: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md with SpriteKit animation architecture"
```

---

## Summary of all files

| # | File | Action |
|---|------|--------|
| 1 | `personal_finance/SpriteKit/ParticleEffects.swift` | Create |
| 2 | `personal_finance/SpriteKit/BackgroundNode.swift` | Create |
| 3 | `personal_finance/SpriteKit/GroundNode.swift` | Create |
| 4 | `personal_finance/SpriteKit/PlantNode.swift` | Create |
| 5 | `personal_finance/SpriteKit/SproutScene.swift` | Create |
| 6 | `personal_finance/Views/SproutTabView.swift` | Modify |
| 7 | `personal_finance/Views/AddTransactionView.swift` | Modify |
| 8 | `CLAUDE.md` | Modify |
